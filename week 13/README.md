# Задачи

> Задача 1

Програмист, който не е обяснявал код на `Rubber Duck` не е програмист!

В тази задача ще направим йерархия на патета.

- Първо ни трябва базов клас `Duck`, който пази данни за височината, цвета и теглото на патето. Трябват ни и следните виртуални методи:
  - quack – чисто виртуален
  - read(istream&)
  - write(ostream&)
  - класът да предефинира операторите за вход и изход

- Следва клас `RubberDuck`, който притежава полета – еластичност на гумата ( число в интервал от 1 – 100 ) и поле дали патето може да дебъгва
- Също така клас `RealDuck`, който съдържа информация за името и възрастта на патето
- И  накрая клас `PlasticDuck`, който представлява пластмасово сглобяемо пате. Патетата от този тип трябва да съдържат информация за броя на елементите, от които са съставени.
- Сега искаме да си направим езеро, за целта – клас `Lake`. Езерото трябва да има име и динамичен масив от патета. Освен това да се съхранява и чете от файл.


> Задача 2

Поток от символи (`Stream`) наричаме обект, който може да дава при поискване последователност от символи(тип `char`). Всеки поток може да има "източник", който за различните видове потоци може да е от различен вид.

- Да се реализира абстрактен клас `Stream`, дефиниращ следните операции за поток:
  - `char get()` - чисто виртуален метод, който "взима" един символ от потока. Ако потокът не разполага с повече символи, функцията да връща `'\0'`. Поведението на `get` се определя от конкретния поток.
  - `std::string take(unsigned n)` - помощен метод, който е реализиран в клас Stream и служи за приемане наведнъж на до n символа(дължината на резултатния низ може да е по-малка от n, ако в потока няма достатъчно символи).

- Да се реализира наследник `StringStream` на `Stream`. Обектите от този поток връщат последователно символите от символен низ, който е подаден като параметър на конструктора им.

```c++
StringStream *s = new StringStream("Hello World!");
std::cout << s->take(10); // Hello Worl
std::cout << s->take(10); //d!
```

- Да се реализира наследник `MergeStreams` на `Stream`. Констуркторът на този поток да получава два указателя към други  "входни" потоци. Символите се получават като алтернативно се сменя входния поток, от който се взима символ, а първия символ се получава от първия поток.

```c++
StringStream *s1 = new StringStream("ABCABC"),
             *s2 = new StringStream("123123"),
             *s3 = new StringStream("=,=,=!");
MergeStreams *m1 = new MergeStreams(s1, s2), *m2 = new MergeStreams(m1, s3);
std::cout << m1->take(6);  // A1B2C3
std::cout << m2->take(12); // A=1,B=2,C=3!
delete s1, s2, s3;
delete m1, m2;
```

- **Бонус:** Да се реализират подходящи канонични методи за йерархията (конструктори, деструктори, оператори за копиране и присвояване). *Упътване: виртуален метод за копиране.*

> Задача 3 

*При решаването на задачата можете да използвате наготово std::string и std::vector.* 

- Реализирайте клас Vehicle (превозно средство). Той трябва да има следните член-данни:
    - regnum – регистрационен номер, константа от тип низ.
За класа да се реализират подходящи конструктори.


Програмата трябва да работи със следните превозни средства - леки коли (car) и камиони (truck). Леките коли имат брой пътници, които могат да превозват и булева стойност, която показва дали водачът е възпитан. Камионите имат поле за товароносимост (load capacity).
Колите и камионите заемат определено пространство когато бъдат паркирани и за него се плаща определена цена.
Цената, която се заплаща за паркиране на съответното превозно средство се пресмята по следния начин:

Цената за паркиране на камион е равна на товароносимостта му разделена на 100.
Ако шофьорът на колата е възпитан, той може да се възползва от специална преферианциална цена - 1 лев. Ако това не е така, цената е между 2 и 10 лева. Точната стойност се определя на случаен принцип при паркирането (използвайте функцията rand())


- Реализирайте клас Garage (гараж). Класът трябва да представя реален гараж, в който може да се паркират различни коли и камиони.
За класа да се реализират подходящи конструктори и методи за добавяне на ново превозно средство към него. Гаражът трябва да може да побира колкото е нужно на брой коли.


- Да се реализира клас Minibus (микробус). Класът представя специално хибридно превозно средство, което прилича на лек автомобил, притежава същите характеристики, но може да превозва и товари. Микробусът има и допълнителна характеристика - брой на вратите.
Да се реализират подходящи конструктори за класа.

Микробусът може да паркира срещу сума, която се изчислява като средно-аритметичното на сумата, за която би паркирал камион със същите характеристики (товароносимост) и сумата за лека кола с тази характеристика за шофьора.


- Реализирайте главна функция, която създава гараж и множество от камиони, коли и микробуси, които да бъдат паркирани в него. Да се реализира функция, която намира общата сума, която притежателят на гаражът ще получи от паркираните  в него автомобили.

- Бонус: Реализирайте Unit Tests за създадените методи и класове.

> Задача 4 

Създайте платформа, чиято функционалност наподобява функционалността на стрийминг услугата **Netflix**.
Потребителите на платформата се представят чрез класа **Account** (потребителски профил), който има за член-данни потребителско име и време на регистрация.

- Реализирайте клас Netflix, който реализира абстрактен клас **StreamingService**. Абстрактният клас StreamingService има следните абстрактни методи:
    - void watch(Account user, std::string videoContentName) – симулира гледане на съдържание с име videoContentName от потребителя user. В случай, че такова
съдържание не съществува в нашата стрийминг услуга, се хвърля изключение със съобщение „Content not found!”. В случай, че такъв потребител не е регистриран, се
хвърля изключение със съобщение „User not found!”.
    - int totalWatchedTimeByUsers() const – връща сумата на минутите, които всички потребители на системата са прекарали, гледайки нейното съдържание. Приемаме, че
ако даден потребител е започнал да гледа видео, той е успял да го завърши. Класът Netflix има конструктор с параметри от вида:
Netflix(Account* accounts, size_t numberOfAccounts, Streamable* streamableContent, size_t numberOfContent).

- Реализирайте абстрактен клас **Streamable** (видео съдържание) с абстрактни методи:
    - std::string getTitle() const – връща заглавието на видео съдържанието;
    - int getDuration() const – връща продължителността на видео съдържанието;
    - **Genre** getGenre() const – връща жанра на видео съдържанието, където Genre e от тип изброен и има стойности ACTION, HORROR и COMEDY;
    - **PgRating** getRating() const – връща рейтинга на видео съдържанието, където PgRating е от тип изброен и има стойности G, PG13 и NC17.

- Абстрактният клас Streamable да се реализира от класовете:
    - **Movie** (филм) – съдържа член-данни име на филма, жанр на филма, рейтинг на филма и продължителност на филма в минути.
    - **Series** (сериал) – съдържа член-данни име на сериала, жанр на сериала, рейтинг на сериала и масив от епизоди на сериала.

За елементите на масива от епизоди създайте клас Episode с член-данни име на епизода и продължителност в минути.

За класовете Account, Movie, Series и Episode създайте гетъри за полетата на класа, както и съответните конструктори с параметри.

Тествайте системата си чрез unit тестове.
